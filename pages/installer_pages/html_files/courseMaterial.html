<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Course Material</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      type="image/png"
      href="../../../img/simpHappyMascotLogo.png"
    />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons+Sharp"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css_files/sideBar.css" />

    <!-- ✅ SweetAlert2 (compact) -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css"
    />
    <style>
      /* Keep SweetAlert popups short so the page never "jumps" */
      .swal2-popup.swal2-compact {
        padding: 0.9rem 1rem !important;
        border-radius: 14px !important;
        width: min(28rem, 92vw) !important;
      }
      .swal2-title {
        font-size: 1.05rem !important;
        font-weight: 700 !important;
        margin-bottom: 0.2rem !important;
      }
      .swal2-html-container {
        font-size: 0.95rem !important;
        line-height: 1.35 !important;
        margin-top: 0.25rem !important;
      }
      .swal2-icon {
        transform: scale(0.9);
        margin: 0.15rem auto 0.35rem !important;
      }
      .swal2-actions .swal2-confirm,
      .swal2-actions .swal2-cancel {
        border-radius: 999px !important;
        padding: 0.5rem 1rem !important;
        font-weight: 700 !important;
      }
    </style>

    <style>
      :root {
        --ink: #1c2430;
        --muted: #6c7a8a;
        --line: #e7edf3;
        --brand: #20a44c;
        --danger: #e53935;
        --card: #ffffff;
        --bg: #f8fbfd;
        --radius: 14px;
        --border: #e5e7eb;
      }
      body {
        background: var(--bg);
      }
      main {
        margin-top: 1.4rem;
      }

      .page-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 1rem;
      }
      .page-header h1 {
        color: var(--ink);
        margin: 0;
      }
      .crumbs {
        font-size: 12px;
        color: #6b7280;
      }

      .card {
        background: #fff;
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 4px 14px rgba(0, 0, 0, 0.06);
      }
      .stack {
        display: grid;
        gap: 14px;
      }

      .section-head {
        font-weight: 700;
        color: #111827;
        margin: 0 0 6px;
      }
      .content-block {
        padding: 12px;
        border: 1px dashed #e5e7eb;
        border-radius: 12px;
        background: #fafcff;
      }
      .content-block video,
      .content-block iframe {
        width: 100%;
        max-height: 420px;
        border-radius: 12px;
      }

      .quiz-wrap {
        display: grid;
        gap: 12px;
      }
      .quiz-title {
        font-weight: 700;
        margin: 0;
      }
      .q-card {
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 12px;
        background: #fff;
      }
      .q-text {
        margin: 0 0 8px;
        font-weight: 600;
      }
      .opts {
        display: grid;
        gap: 8px;
      }
      .opt {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .muted {
        color: #6b7280;
      }
      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .pill {
        background: #eef6ff;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid #d7e7ff;
        font-size: 12px;
      }
      .pill.good {
        background: #ecfdf5;
        border-color: #bbf7d0;
        color: #065f46;
      }
      .pill.bad {
        background: #fef2f2;
        border-color: #fecaca;
        color: #991b1b;
      }

      .btn {
        border: 1px solid var(--brand);
        background: var(--brand);
        color: #fff;
        padding: 10px 14px;
        border-radius: 999px;
        cursor: pointer;
        text-decoration: none; /* so <a class="btn"> looks like button */
        display: inline-block;
      }
      .btn.secondary {
        background: #fff;
        color: #0f172a;
        border-color: #d1e7db;
      }
      .btn[disabled] {
        opacity: 0.7;
        cursor: not-allowed;
      }

      .result {
        padding: 12px;
        border-radius: 12px;
        border: 1px solid #e5e7eb;
        background: #f9fafb;
        display: none;
      }
      .result.pass {
        border-color: #bbf7d0;
        background: #ecfdf5;
        color: #065f46;
      }
      .result.fail {
        border-color: #fecaca;
        background: #fef2f2;
        color: #7f1d1d;
      }

      .skeleton {
        background: linear-gradient(
          90deg,
          #f2f4f7 25%,
          #e9edf2 37%,
          #f2f4f7 63%
        );
        background-size: 400% 100%;
        animation: shimmer 1.2s infinite;
        border-radius: 12px;
        height: 18px;
      }
      @keyframes shimmer {
        0% {
          background-position: 100% 0;
        }
        100% {
          background-position: -100% 0;
        }
      }

      /* Navigation bar below sections */
      .section-nav {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
      }
      .blur-locked {
        filter: blur(3px);
        pointer-events: none;
        user-select: none;
      }
      .tiny {
        font-size: 12px;
        color: #6b7280;
      }
      .badge {
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid #e5e7eb;
        font-size: 11px;
        background: #fff;
      }

      /* Per-question points label */
      .q-points {
        margin-top: 6px;
        font-size: 12px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .q-points .ok {
        background: #ecfdf5;
        color: #065f46;
        border: 1px solid #bbf7d0;
        padding: 2px 8px;
        border-radius: 999px;
      }
      .q-points .miss {
        background: #fef2f2;
        color: #991b1b;
        border: 1px solid #fecaca;
        padding: 2px 8px;
        border-radius: 999px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Sidebar -->
      <aside>
        <div class="toggle">
          <div class="logo">
            <img src="../images/STEQ Logo 3.png" />
            <h2>SIMP<span class="danger">Project</span></h2>
          </div>
          <div class="close" id="close-btn">
            <span class="material-icons-sharp">close</span>
          </div>
        </div>

        <div class="sidebar">
          <a href="dashboard.html">
            <span class="material-icons-sharp">dashboard</span>
            <h3>Dashboard</h3>
          </a>
          <a href="job.html">
            <span class="material-icons-sharp">work</span>
            <h3>Jobs</h3>
          </a>
          <a href="myApplication.html">
            <span class="material-icons-sharp">receipt</span>
            <h3>My Application</h3>
          </a>
          <a href="courses.html" class="active">
            <span class="material-icons-sharp">school</span>
            <h3>Courses</h3>
          </a>
          <a href="shop.html">
            <span class="material-icons-sharp">shopping_cart</span>
            <h3>Shop</h3>
          </a>
          <a href="earnings.html">
            <span class="material-icons-sharp">account_balance</span>
            <h3>Earnings</h3>
          </a>
          <a href="documents.html">
            <span class="material-icons-sharp">file_copy</span>
            <h3>Documents</h3>
          </a>
          <a href="settings.html">
            <span class="material-icons-sharp">settings</span>
            <h3>Settings</h3>
          </a>
          <a href="#" id="logout-btn">
            <span class="material-icons-sharp">logout</span>
            <h3>Logout</h3>
          </a>
        </div>
      </aside>

      <!-- Main -->
      <main>
        <div class="page-header">
          <div>
            <div class="crumbs">
              <a href="courses.html" class="muted">Courses</a> /
              <span id="crumbCourse">Loading…</span>
            </div>
            <h1 id="courseTitle">Loading course…</h1>
            <div class="row">
              <span id="courseLevel" class="pill">Level —</span>
              <span id="courseTags" class="pill">Tags: —</span>
              <!-- hidden per previous request -->
              <span id="passingInfo" class="pill good" style="display: none"
                >Passing: —</span
              >
              <span id="timeInfo" class="pill" style="display: none"
                >Time limit: —</span
              >
            </div>
          </div>
          <div class="row">
            <button id="backBtn" class="btn secondary" type="button">
              ← Back
            </button>
          </div>
        </div>

        <!-- Course content -->
        <div class="stack" id="contentStack">
          <div class="card">
            <h3 class="section-head">Overview</h3>
            <p id="courseDesc" class="muted">Loading description…</p>
          </div>

          <div class="card" id="sectionsCard" style="display: none">
            <h3 class="section-head">Sections</h3>

            <!-- One section page at a time -->
            <div id="sectionPagesWrap" class="stack"></div>

            <!-- Navigation bar -->
            <div class="section-nav" id="sectionNav" style="display: none">
              <button id="navPrev" class="btn secondary" type="button">
                ← Back
              </button>
              <div class="tiny">
                <span class="badge" id="pageBadge">Section 1 / 1</span>
              </div>
              <button id="navNext" class="btn" type="button">Next →</button>
              <button
                id="navSubmit"
                class="btn"
                type="button"
                style="display: none"
              >
                Submit
              </button>
            </div>
          </div>

          <!-- Results card (kept; submit row hidden) -->
          <div class="card" id="quizCard" style="display: none">
            <div
              class="row"
              style="justify-content: space-between; align-items: baseline"
            >
              <h3 class="quiz-title">Result</h3>
              <div class="muted" id="timerLabel" style="display: none">
                Time left: <strong id="timerTxt">—</strong>
              </div>
            </div>
            <form id="quizForm" class="quiz-wrap"></form>
            <div
              class="row"
              id="legacySubmitRow"
              style="margin-top: 8px; display: none"
            >
              <button id="submitBtn" class="btn" type="button">
                Submit Answers
              </button>
              <span class="muted" id="quizNote"></span>
            </div>
            <div
              id="quizResult"
              class="result"
              role="status"
              aria-live="polite"
            ></div>
          </div>
        </div>
      </main>
    </div>

    <script src="../../general_files/index.js"></script>
    <script type="module" src="../../general_files/session.js"></script>

    <!-- SweetAlert2 JS -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <!-- Supabase -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script type="module">
      import { SUPABASE_URL, SUPABASE_ANON_KEY } from "../../../supabase.js";
      const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      const sbCourses = window.supabase.createClient(
        SUPABASE_URL,
        SUPABASE_ANON_KEY,
        { db: { schema: "courses" } }
      );

      // ✅ SweetAlert2 helpers (compact + friendly)
      const toast = Swal.mixin({
        toast: true,
        position: "top-end",
        showConfirmButton: false,
        timer: 2400,
        timerProgressBar: true,
      });

      function notify(type = "info", title = "", text = "") {
        if (type === "error" || type === "warning") {
          return Swal.fire({
            icon: type,
            title:
              title || (type === "error" ? "Something went wrong" : "Heads up"),
            text: text || "",
            customClass: { popup: "swal2-compact" },
            confirmButtonText: "OK",
          });
        }
        return toast.fire({ icon: type, title: title || text || "" });
      }

      function confirmModal(title, text) {
        return Swal.fire({
          icon: "question",
          title,
          text,
          showCancelButton: true,
          confirmButtonText: "Continue",
          cancelButtonText: "Cancel",
          customClass: { popup: "swal2-compact" },
        });
      }

      // UI elements
      const courseTitle = document.getElementById("courseTitle");
      const crumbCourse = document.getElementById("crumbCourse");
      const courseDesc = document.getElementById("courseDesc");
      const courseLevel = document.getElementById("courseLevel");
      const courseTags = document.getElementById("courseTags");
      const passingInfo = document.getElementById("passingInfo");
      const timeInfo = document.getElementById("timeInfo");

      const sectionsCard = document.getElementById("sectionsCard");
      const sectionPagesWrap = document.getElementById("sectionPagesWrap");
      const sectionNav = document.getElementById("sectionNav");
      const navPrev = document.getElementById("navPrev");
      const navNext = document.getElementById("navNext");
      const navSubmit = document.getElementById("navSubmit");
      const pageBadge = document.getElementById("pageBadge");

      // Legacy elements (kept/hidden)
      const quizCard = document.getElementById("quizCard");
      const quizForm = document.getElementById("quizForm");
      const submitBtn = document.getElementById("submitBtn");
      const quizResult = document.getElementById("quizResult");
      const quizNote = document.getElementById("quizNote");
      const timerLabel = document.getElementById("timerLabel");
      const timerTxt = document.getElementById("timerTxt");
      const backBtn = document.getElementById("backBtn");

      backBtn.addEventListener("click", () => history.back());

      // Helpers
      function qs(name) {
        const p = new URLSearchParams(location.search);
        return p.get(name) || "";
      }
      function esc(s) {
        return String(s ?? "").replace(
          /[&<>'"]/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              "'": "&#39;",
              '"': "&quot;",
            }[c])
        );
      }
      function el(tag, attrs = {}, children = []) {
        const n = document.createElement(tag);
        Object.entries(attrs).forEach(([k, v]) => {
          if (k === "class") n.className = v;
          else if (k === "html") n.innerHTML = v;
          else n.setAttribute(k, v);
        });
        children.forEach((c) => n.appendChild(c));
        return n;
      }

      // State
      let course = null;

      // ===== NEW: track installer's current level for level-up logic =====
      let CURRENT_USER_LEVEL = 0;

      // Multi-quiz state
      const quizzesById = new Map(); // quizId -> quiz object
      const questionsByQuizId = new Map(); // quizId -> questions[]
      const timersByQuizId = new Map(); // quizId -> {deadline, intervalId, labelEl}
      const quizStarted = new Set(); // quizId that has started
      let navLocked = false;
      let sections = [];
      let contentsBySection = {};
      let orderedSectionIds = [];
      let currentIdx = 0;

      // Legacy single-quiz (kept, hidden)
      let quiz = null;
      let questions = [];
      let timer = null;
      let deadlineTs = 0;

      async function requireUser() {
        const {
          data: { user },
        } = await sb.auth.getUser();
        if (!user) {
          await Swal.fire({
            icon: "warning",
            title: "Sign in required",
            text: "Please sign in to take this course.",
            confirmButtonText: "Go to Login",
            customClass: { popup: "swal2-compact" },
          });
          window.location.href = "../auth/login.html";
          return null;
        }
        return user;
      }

      async function loadCourse(slug) {
        const { data, error } = await sbCourses
          .from("course")
          .select(
            "id,title,slug,description,level,tags,is_published,created_at"
          )
          .eq("slug", slug)
          .eq("is_published", true)
          .maybeSingle();

        if (error || !data)
          throw new Error("This course was not found or isn’t published yet.");
        return data;
      }

      async function loadSections(courseId) {
        const { data, error } = await sbCourses
          .from("section")
          .select("id,title,position")
          .eq("course_id", courseId)
          .order("position", { ascending: true });
        if (error) throw error;
        return data || [];
      }

      async function loadSectionContent(sectionIds) {
        if (!sectionIds.length) return [];
        const { data, error } = await sbCourses
          .from("section_content")
          .select(
            "id,section_id,content_type,position,body,video_url,quiz_id,duration_seconds"
          )
          .in("section_id", sectionIds)
          .order("position", { ascending: true });
        if (error) throw error;
        return data || [];
      }

      async function loadQuestions(quizId) {
        const { data, error } = await sbCourses
          .from("quiz_question")
          .select("id,quiz_id,position,question,options,correct_answer,points")
          .eq("quiz_id", quizId)
          .order("position", { ascending: true });
        if (error) throw error;
        return data || [];
      }

      function toYouTubeEmbed(url) {
        try {
          const u = new URL(url);
          if (u.hostname.includes("youtu.be")) {
            return `https://www.youtube.com/embed/${u.pathname.slice(1)}`;
          }
          if (u.hostname.includes("youtube.com")) {
            const id = u.searchParams.get("v");
            if (id) return `https://www.youtube.com/embed/${id}`;
          }
        } catch {}
        return url;
      }

      // ====== NEW: Installer level helpers (non-destructive additions) ======
      async function loadInstallerLevel() {
        try {
          const {
            data: { user },
          } = await sb.auth.getUser();
          if (!user) return;
          const { data, error } = await sb
            .from("installer")
            .select("levelstatus")
            .eq("id", user.id)
            .single();
          if (!error && data && typeof data.levelstatus === "number") {
            CURRENT_USER_LEVEL = Number(data.levelstatus) || 0;
          }
        } catch (e) {
          console.warn("loadInstallerLevel failed:", e);
        }
      }

      // Increment by exactly +1 AFTER inserting into completed_courses.
      // Uses optimistic concurrency: only updates when current level equals expected "old" level.
      async function incrementLevelAfterInsert(passedCourseLevel) {
        try {
          const {
            data: { user },
          } = await sb.auth.getUser();
          if (!user) return { leveled: false };

          // Read current from DB (compare-and-set)
          const { data: row, error } = await sb
            .from("installer")
            .select("levelstatus")
            .eq("id", user.id)
            .single();
          if (error) {
            console.warn("Read levelstatus failed:", error);
            return { leveled: false };
          }

          const current = Number(row?.levelstatus ?? 0);
          const expectedNext = current + 1;

          // Only level up if the course passed is exactly the next level.
          if (Number(passedCourseLevel) !== expectedNext) {
            return { leveled: false };
          }

          // Try to set levelstatus = current + 1, only if still at 'current'
          const { data: upd, error: updErr } = await sb
            .from("installer")
            .update({ levelstatus: expectedNext })
            .eq("id", user.id)
            .eq("levelstatus", current) // CAS: prevents duplicate increment across refreshes
            .select("levelstatus");

          if (updErr) {
            console.warn("Level up update failed:", updErr);
            return { leveled: false };
          }

          const leveled = Array.isArray(upd) ? upd.length > 0 : !!upd; // PostgREST returns array
          if (leveled) {
            CURRENT_USER_LEVEL = expectedNext;
          }
          return { leveled };
        } catch (e) {
          console.warn("incrementLevelAfterInsert exception:", e);
          return { leveled: false };
        }
      }
      // ====== /NEW helpers ======

      // RENDERING ----------------------------------------------------

      function renderSectionPage(sec, items) {
        const page = el("div", { class: "stack", "data-section-id": sec.id });

        page.appendChild(
          el("h4", { class: "section-head", html: esc(sec.title) })
        );

        (items || []).forEach((item) => {
          if (item.content_type === "text" && item.body) {
            const block = el("div", { class: "content-block" });
            block.appendChild(
              el("div", {
                class: "muted",
                html: esc(item.body).replace(/\n/g, "<br>"),
              })
            );
            page.appendChild(block);
          } else if (item.content_type === "video" && item.video_url) {
            const block = el("div", { class: "content-block" });
            if (/youtube\.com|youtu\.be/.test(item.video_url)) {
              const iframe = el("iframe", {
                src: toYouTubeEmbed(item.video_url),
                allowfullscreen: "",
                style: "min-height:300px;border:0;border-radius:12px",
              });
              block.appendChild(iframe);
            } else {
              const vid = el("video", { controls: "", src: item.video_url });
              block.appendChild(vid);
            }
            page.appendChild(block);
          } else if (item.content_type === "quiz" && item.quiz_id) {
            const block = el("div", { class: "content-block" });

            const qzId = item.quiz_id;
            const qz = quizzesById.get(qzId);
            const qs = questionsByQuizId.get(qzId) || [];

            const header = el(
              "div",
              {
                class: "row",
                style: "justify-content:space-between; align-items:center;",
              },
              [
                el("div", {}, [
                  el("div", {
                    class: "quiz-title",
                    html: esc(qz?.title || "Quiz"),
                  }),
                  /* Per-quiz passing score shown */
                  el("div", {
                    class: "tiny",
                    html: `Passing: ${qz?.passing_score ?? 70}% • ${
                      qs.length
                    } question(s)`,
                  }),
                ]),
                el("div", { class: "tiny" }, [
                  el("span", {
                    class: "badge",
                    id: `timer_label_${qzId}`,
                    html: `Timer: —`,
                  }),
                ]),
              ]
            );
            block.appendChild(header);

            const controls = el("div", {
              class: "row",
              style: "margin:8px 0;",
            });
            const startBtn = el(
              "button",
              { class: "btn", type: "button", id: `start_${qzId}` },
              [document.createTextNode("Start Quiz")]
            );
            const finishBtn = el(
              "button",
              {
                class: "btn secondary",
                type: "button",
                id: `finish_${qzId}`,
                disabled: "",
              },
              [document.createTextNode("Finish Quiz")]
            );
            controls.appendChild(startBtn);
            controls.appendChild(finishBtn);
            block.appendChild(controls);

            const blurWrap = el("div", {
              id: `quiz_wrap_${qzId}`,
              class: "quiz-wrap blur-locked",
            });
            qs.forEach((q, idx) => {
              const qDiv = el("div", { class: "q-card" });
              qDiv.appendChild(
                el("div", {
                  class: "q-text",
                  html: `${idx + 1}. ${esc(q.question)}`,
                })
              );

              const optsWrap = el("div", { class: "opts" });
              const options = q.options || {};
              ["A", "B", "C", "D"].forEach((letter) => {
                if (options[letter] == null) return;
                const id = `q_${q.id}_${letter}`;
                const row = el("label", { class: "opt", for: id });
                const input = el("input", {
                  type: "radio",
                  name: `q_${q.id}`,
                  id,
                  value: letter,
                });
                const span = el("span", {
                  html: `<strong>${letter}.</strong> ${esc(
                    String(options[letter])
                  )}`,
                });
                row.appendChild(input);
                row.appendChild(span);
                optsWrap.appendChild(row);
              });
              qDiv.appendChild(optsWrap);

              /* Per-question points result placeholder */
              qDiv.appendChild(
                el("div", { class: "q-points", id: `qpts_${q.id}` })
              );

              blurWrap.appendChild(qDiv);
            });
            block.appendChild(blurWrap);

            page.appendChild(block);

            // hook up actions
            startBtn.addEventListener("click", () => startQuiz(item.quiz_id));
            finishBtn.addEventListener("click", () => finishQuiz(item.quiz_id));
          }
        });

        page.style.display = "none";
        return page;
      }

      function renderAllSectionPages() {
        sectionPagesWrap.innerHTML = "";
        orderedSectionIds = sections.map((s) => s.id);
        sections.forEach((sec) => {
          const items = contentsBySection[sec.id] || [];
          const page = renderSectionPage(sec, items);
          sectionPagesWrap.appendChild(page);
        });

        if (sections.length) {
          sectionNav.style.display = "";
          currentIdx = 0;
          syncPager();
        }
      }

      function syncPager() {
        const total = orderedSectionIds.length;
        for (let i = 0; i < total; i++) {
          const secId = orderedSectionIds[i];
          const pageEl = sectionPagesWrap.querySelector(
            `[data-section-id="${secId}"]`
          );
          if (pageEl) pageEl.style.display = i === currentIdx ? "" : "none";
        }

        pageBadge.textContent = `Section ${total ? currentIdx + 1 : 0} / ${
          total || 0
        }`;
        navPrev.disabled = navLocked || currentIdx === 0;
        navNext.style.display = currentIdx < total - 1 ? "" : "none";
        navNext.disabled = navLocked;
        navSubmit.style.display = currentIdx === total - 1 ? "" : "none";
        navSubmit.disabled = navLocked;
      }

      navPrev.addEventListener("click", () => {
        if (navLocked) return;
        if (currentIdx > 0) {
          currentIdx--;
          syncPager();
        }
      });
      navNext.addEventListener("click", () => {
        if (navLocked) return;
        const total = orderedSectionIds.length;
        if (currentIdx < total - 1) {
          currentIdx++;
          syncPager();
        }
      });

      // QUIZ TIMING & FLOW ------------------------------------------

      function startQuiz(quizId) {
        if (quizStarted.has(quizId)) return;
        const qz = quizzesById.get(quizId);
        const wrap = document.getElementById(`quiz_wrap_${quizId}`);
        const startBtn = document.getElementById(`start_${quizId}`);
        const finishBtn = document.getElementById(`finish_${quizId}`);
        const label = document.getElementById(`timer_label_${quizId}`);

        wrap.classList.remove("blur-locked");
        navLocked = true;
        syncPager();

        startBtn.disabled = true;
        finishBtn.disabled = false;
        quizStarted.add(quizId);

        if (qz && qz.time_limit_seconds) {
          const deadline = Date.now() + qz.time_limit_seconds * 1000;
          const intervalId = setInterval(() => {
            const left = Math.max(0, deadline - Date.now());
            const s = Math.ceil(left / 1000);
            const mm = Math.floor(s / 60)
              .toString()
              .padStart(2, "0");
            const ss = (s % 60).toString().padStart(2, "0");
            if (label) label.textContent = `Timer: ${mm}:${ss}`;
            if (left <= 0) {
              clearInterval(intervalId);
              timersByQuizId.delete(quizId);
              finishQuiz(quizId, /*auto*/ true);
            }
          }, 250);
          timersByQuizId.set(quizId, { deadline, intervalId, labelEl: label });
        } else {
          if (label) label.textContent = `Timer: —`;
        }
      }

      // Mark per-question points for ONE quiz (used on Finish Quiz)
      function annotateQuizQuestionPoints(quizId) {
        const qs = questionsByQuizId.get(quizId) || [];
        qs.forEach((q) => {
          const pts = Number(q.points || 1);
          const chosen = (
            document.querySelector(`input[name="q_${q.id}"]:checked`) || {}
          ).value;
          const ok =
            chosen &&
            String(chosen).toUpperCase() ===
              String(q.correct_answer).toUpperCase();
          const target = document.getElementById(`qpts_${q.id}`);
          if (target) {
            target.innerHTML = ok
              ? `<span class="ok">✓ +${pts} / ${pts} pts</span>`
              : `<span class="miss">0 / ${pts} pts</span>`;
          }
        });
      }

      function finishQuiz(quizId, auto = false) {
        const startBtn = document.getElementById(`start_${quizId}`);
        const finishBtn = document.getElementById(`finish_${quizId}`);

        const t = timersByQuizId.get(quizId);
        if (t && t.intervalId) clearInterval(t.intervalId);
        timersByQuizId.delete(quizId);

        // Annotate per-question points immediately when finishing this quiz
        annotateQuizQuestionPoints(quizId);

        navLocked = false;
        syncPager();

        startBtn.disabled = true;
        finishBtn.disabled = true;

        if (auto) {
          notify(
            "warning",
            "Time's up",
            "Your answers for this quiz have been recorded."
          );
        } else {
          notify("success", "Quiz finished");
        }
      }

      // SCORING ------------------------------------------------------

      function computeOverallScore() {
        let totalPts = 0;
        let earnedPts = 0;
        let passingWeightedSum = 0;

        quizzesById.forEach((qz, quizId) => {
          const qs = questionsByQuizId.get(quizId) || [];
          let quizTotal = 0;

          qs.forEach((q) => {
            const pts = Number(q.points || 1);
            quizTotal += pts;
            totalPts += pts;

            const chosen = (
              document.querySelector(`input[name="q_${q.id}"]:checked`) || {}
            ).value;
            const ok =
              chosen &&
              String(chosen).toUpperCase() ===
                String(q.correct_answer).toUpperCase();
            if (ok) earnedPts += pts;

            // Also (re)annotate per-question points when doing the final submit
            const target = document.getElementById(`qpts_${q.id}`);
            if (target) {
              target.innerHTML = ok
                ? `<span class="ok">✓ +${pts} / ${pts} pts</span>`
                : `<span class="miss">0 / ${pts} pts</span>`;
            }
          });

          if (quizTotal > 0) {
            passingWeightedSum += quizTotal * (qz.passing_score ?? 70);
          }
        });

        const pct = totalPts > 0 ? Math.round((earnedPts / totalPts) * 100) : 0;
        const combinedPassing =
          totalPts > 0 ? Math.round(passingWeightedSum / totalPts) : 70;
        return { totalPts, earnedPts, pct, combinedPassing };
      }

      // ====== MODIFIED: trigger level update *after* insert to completed_courses ======
      async function saveCompletionIfPass(
        courseId,
        pct,
        combinedPassing,
        passedCourseLevel
      ) {
        if (pct < combinedPassing) return { saved: false, leveled: false };

        const {
          data: { user },
        } = await sb.auth.getUser();
        if (!user) throw new Error("You must be signed in.");

        // Check if a completion row already exists (to know if this is an insert)
        const { data: existingRow, error: existErr } = await sbCourses
          .from("completed_courses")
          .select("course_id")
          .eq("installer_id", user.id)
          .eq("course_id", courseId)
          .maybeSingle();

        if (existErr) {
          console.warn("Existence check error:", existErr);
        }

        const isFirstInsert = !existingRow;

        // Upsert the completion (this is the required "insert first" step)
        const { error: upErr } = await sbCourses
          .from("completed_courses")
          .upsert(
            { course_id: courseId, score: pct },
            { onConflict: "installer_id,course_id" }
          )
          .select("course_id");

        if (upErr) throw upErr;

        // Only trigger level increment AFTER (first) insert to completed_courses
        let leveled = false;
        if (isFirstInsert) {
          const res = await incrementLevelAfterInsert(passedCourseLevel);
          leveled = !!res?.leveled;
        }

        return { saved: true, leveled };
      }
      // ====== /MODIFIED ======

      // Legacy single-quiz bits (hidden UI, kept for compatibility)
      function startTimerIfNeeded(qz) {
        if (!qz || !qz.time_limit_seconds) return;
        timerLabel.style.display = "";
        const seconds = qz.time_limit_seconds;
        deadlineTs = Date.now() + seconds * 1000;
        updateTimer();
        timer = setInterval(updateTimer, 250);
      }
      function updateTimer() {
        const left = Math.max(0, deadlineTs - Date.now());
        const s = Math.ceil(left / 1000);
        const mm = Math.floor(s / 60)
          .toString()
          .padStart(2, "0");
        const ss = (s % 60).toString().padStart(2, "0");
        timerTxt.textContent = `${mm}:${ss}`;
        if (left <= 0) {
          clearInterval(timer);
          timer = null;
          gradeAndSubmit(true);
        }
      }
      function computeScore(qs) {
        let total = 0;
        let earned = 0;
        qs.forEach((q) => {
          const pts = Number(q.points || 1);
          total += pts;
          const chosen = (
            document.querySelector(`input[name="q_${q.id}"]:checked`) || {}
          ).value;
          if (
            chosen &&
            String(chosen).toUpperCase() ===
              String(q.correct_answer).toUpperCase()
          ) {
            earned += pts;
          }
        });
        const pct = total > 0 ? Math.round((earned / total) * 100) : 0;
        return { total, earned, pct };
      }
      async function gradeAndSubmit(auto = false) {
        try {
          const { pct, total, earned } = computeScore(questions);
          const pass = pct >= (quiz?.passing_score ?? 70);
          quizResult.classList.remove("pass", "fail");
          quizResult.style.display = "block";
          quizResult.innerHTML = `<div><strong>Score:</strong> ${pct}% <span class="muted">(${earned}/${total} pts)</span></div>`;
          if (pass) {
            const { saved, leveled } = await saveCompletionIfPass(
              course.id,
              pct,
              quiz.passing_score ?? 70,
              course.level
            );
            quizResult.classList.add("pass");
            quizResult.innerHTML += `<div class="muted">✅ Passed. ${
              saved ? "Your completion was recorded." : ""
            }${leveled ? " • Level +1" : ""}</div>`;
            notify("success", "Nice work!", "You passed this quiz.");
          } else {
            quizResult.classList.add("fail");
            quizResult.innerHTML += `<div class="muted">❌ Almost there—review and try again when ready.</div>`;
            notify(
              "warning",
              "Not quite passed",
              "Give it another try after a quick review."
            );
          }
        } catch (e) {
          notify(
            "error",
            "Submission failed",
            e.message || "We couldn’t save your quiz result."
          );
        }
      }
      submitBtn?.addEventListener("click", () => gradeAndSubmit(false));

      // --------- NEW: Retake functionality ---------
      function retakeCourse() {
        // Stop all timers
        timersByQuizId.forEach((t) => {
          if (t.intervalId) clearInterval(t.intervalId);
        });
        timersByQuizId.clear();

        // Reset per-quiz UI
        quizzesById.forEach((qz, quizId) => {
          // Blur/lock quiz again
          const wrap = document.getElementById(`quiz_wrap_${quizId}`);
          if (wrap) {
            wrap.classList.add("blur-locked");
            // clear answers
            const inputs = wrap.querySelectorAll('input[type="radio"]');
            inputs.forEach((i) => (i.checked = false));
            // clear per-question points labels
            wrap
              .querySelectorAll(".q-points")
              .forEach((p) => (p.innerHTML = ""));
          }
          // reset buttons
          const startBtn = document.getElementById(`start_${quizId}`);
          const finishBtn = document.getElementById(`finish_${quizId}`);
          if (startBtn) startBtn.disabled = false;
          if (finishBtn) finishBtn.disabled = true;
          // reset timer label
          const label = document.getElementById(`timer_label_${quizId}`);
          if (label) label.textContent = "Timer: —";
        });

        quizStarted.clear();
        navLocked = false;

        // Hide result panel and go back to first section
        quizResult.classList.remove("pass", "fail");
        quizResult.style.display = "none";
        quizForm.innerHTML = "";
        currentIdx = 0;
        syncPager();
        window.scrollTo({ top: 0, behavior: "smooth" });
        notify("info", "Course reset", "You can retake the quizzes anytime.");
      }

      // Final submit (last section)
      navSubmit.addEventListener("click", async () => {
        if (navLocked) return;
        timersByQuizId.forEach((t) => {
          if (t.intervalId) clearInterval(t.intervalId);
        });
        timersByQuizId.clear();

        const { totalPts, earnedPts, pct, combinedPassing } =
          computeOverallScore();

        quizCard.style.display = "";
        quizResult.classList.remove("pass", "fail");
        quizResult.style.display = "block";
        quizForm.innerHTML = "";
        const legacyRow = document.getElementById("legacySubmitRow");
        if (legacyRow) legacyRow.style.display = "none";
        quizNote.textContent = `Combined passing: ${combinedPassing}%`;
        quizResult.innerHTML = `<div><strong>Overall Score:</strong> ${pct}% <span class="muted">(${earnedPts}/${totalPts} pts)</span></div>`;

        try {
          if (pct >= combinedPassing) {
            const { saved, leveled } = await saveCompletionIfPass(
              course.id,
              pct,
              combinedPassing,
              course.level
            );
            quizResult.classList.add("pass");
            quizResult.innerHTML += `<div class="muted">✅ Passed. ${
              saved ? "Your completion was recorded." : ""
            }${leveled ? " • Level +1" : ""}</div>`;
            notify("success", "Congratulations!", "You passed the course.");
          } else {
            quizResult.classList.add("fail");
            quizResult.innerHTML += `<div class="muted">❌ Not yet passed. Review the sections and try again.</div>`;
            // NEW: Retake button on fail
            quizResult.innerHTML += `
              <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
                <button class="btn secondary" id="retakeCourseBtn" type="button">↻ Retake Course</button>
                <a class="btn" href="courses.html">← Back to Courses</a>
              </div>
            `;
            quizResult.scrollIntoView({ behavior: "smooth", block: "center" });
            notify(
              "warning",
              "Keep going!",
              "You’re close—give it another shot."
            );
            return; // keep early return so success branch below doesn't duplicate links
          }

          /* Back to Courses button after submitting (pass case) */
          quizResult.innerHTML += `
            <div style="margin-top:10px;">
              <a class="btn" href="courses.html">← Back to Courses</a>
            </div>
          `;

          quizResult.scrollIntoView({ behavior: "smooth", block: "center" });
        } catch (e) {
          notify(
            "error",
            "Save failed",
            e.message || "We couldn’t record your completion."
          );
        }
      });

      // Delegate click for retake button (added only on fail)
      document.addEventListener("click", (e) => {
        const tgt = e.target;
        if (tgt && tgt.id === "retakeCourseBtn") {
          e.preventDefault();
          retakeCourse();
        }
      });

      // INIT ---------------------------------------------------------
      (async function init() {
        const user = await requireUser();
        if (!user) return;

        // Load installer level to have CURRENT_USER_LEVEL available (used in UI elsewhere if needed)
        await loadInstallerLevel();

        const slug = qs("course");
        if (!slug) {
          await Swal.fire({
            icon: "warning",
            title: "Missing course link",
            text: "We couldn’t find which course to open.",
            confirmButtonText: "Back to Courses",
            customClass: { popup: "swal2-compact" },
          });
          window.location.href = "courses.html";
          return;
        }

        try {
          course = await loadCourse(slug);
          crumbCourse.textContent = course.title;
          courseTitle.textContent = course.title;
          courseDesc.textContent = course.description || "No description.";
          courseLevel.textContent = `Level ${
            Number.isFinite(course.level) ? course.level : 0
          }`;
          courseTags.textContent = `Tags: ${
            Array.isArray(course.tags) && course.tags.length
              ? course.tags.join(", ")
              : "—"
          }`;

          sections =
            (await (
              await sbCourses
                .from("section")
                .select("id,title,position")
                .eq("course_id", course.id)
                .order("position", { ascending: true })
            ).data) || [];

          if (sections.length) {
            const allContents =
              (
                await sbCourses
                  .from("section_content")
                  .select(
                    "id,section_id,content_type,position,body,video_url,quiz_id,duration_seconds"
                  )
                  .in(
                    "section_id",
                    sections.map((s) => s.id)
                  )
                  .order("position", { ascending: true })
              ).data || [];

            contentsBySection = {};
            sections.forEach((s) => (contentsBySection[s.id] = []));
            allContents.forEach((c) => {
              if (!contentsBySection[c.section_id])
                contentsBySection[c.section_id] = [];
              contentsBySection[c.section_id].push(c);
            });

            // Preload quizzes
            const uniqueQuizIds = Array.from(
              new Set(
                allContents
                  .filter((c) => c.content_type === "quiz" && c.quiz_id)
                  .map((c) => c.quiz_id)
              )
            );
            if (uniqueQuizIds.length) {
              const { data: qzs } = await sbCourses
                .from("quiz")
                .select(
                  "id,course_id,title,passing_score,time_limit_seconds,created_at"
                )
                .in("id", uniqueQuizIds);
              (qzs || []).forEach((qz) => quizzesById.set(qz.id, qz));

              for (const qid of uniqueQuizIds) {
                const qs =
                  (await (
                    await sbCourses
                      .from("quiz_question")
                      .select(
                        "id,quiz_id,position,question,options,correct_answer,points"
                      )
                      .eq("quiz_id", qid)
                      .order("position", { ascending: true })
                  ).data) || [];
                questionsByQuizId.set(qid, qs);
              }
            }

            sectionsCard.style.display = "";
            renderAllSectionPages();
            notify("success", "Course loaded");
          } else {
            notify(
              "info",
              "No sections yet",
              "This course has no content to display."
            );
          }

          // Legacy single-quiz block remains hidden by default.
        } catch (e) {
          await Swal.fire({
            icon: "error",
            title: "Unable to open course",
            text: e.message || "Please try again later.",
            confirmButtonText: "Back to Courses",
            customClass: { popup: "swal2-compact" },
          });
          window.location.href = "courses.html";
        }
      })();
    </script>
  </body>
</html>
